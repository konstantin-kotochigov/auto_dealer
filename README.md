# bmw

## Постановка задачи

Будем рассматривать последовательности событий между которыми не более 4 часов. 
Такие последовательности будем условно называть **сессиями**. 
Временем сессии (ts) будем обозначать последнее событие последовательности . 
За прасстояние между сессиями возмем расстояние между последним событием текущей и первым событием следующей сессии (delta).

Если события нету, delta = inf.
Целевая переменная target = 0, если delta = inf и target=1 иначе.

Однако если событие свежее, клиент мог просто не успеть зайти на сайт. Поэтому необходимо определить окно возврата клиента. Для этого строим распределениq расстояний между сессиями и берем минимально допустимое: return_window = 1m.

Таким образом target = 1, если 4h < delta < 1m, и target = 0, если delta >= 1m

Из-за наличия окна возврата в обучающей выборке можем использовать только сессии, у которых ts <= current_dt - return_window. Остальные фильтруем.

При таком подходе легко инкерментально обучать модель. Видно, что между загрузками старые сессии не изменяются, но могут появляться новые. Поэтому просто фильтруем dt - 4w < ts < dt - 3w для получения дельты и скармливаем её модели.

Каждая сессия содержит всю информацию. 

Есть 2 режима генерации обучающей выборки:
ALL - генерируется отдельный кейс на каждую сессию
n - по каждому клиенту генерируется один кейс на указанную дату

Второй режим точнее повторяет применение модели к новым данным. Плюс гарантирует, что не будет Data Leakage, когда модель запоминает> предыдущие сессии.

Каждая сессия помимо своих запросов содержит всю предыдущую историю.
Ссылки запросов и расстояние в минутах между запросами.
